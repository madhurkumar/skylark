{"name":"Skylark","tagline":"","body":"# Skylark\r\n\r\nSkylark is a set of libraries for quantitative and financial computation.\r\n\r\n## slylark-learning-neural\r\n\r\n**skylark-learning-neural** is a library for training, testing, and using neural networks.\r\n\r\nThe example below shows how to train and test a feed-forward network using a backpropagation trainer on [MNIST database of handwritten digits](http://yann.lecun.com/exdb/mnist).\r\n\r\n```scala\r\n// Load training and test data\r\nval trainingDataProvider = new MnistDataProvider(\"data/mnist/train-images-idx3-ubyte\", \"data/mnist/train-labels-idx1-ubyte\")\r\n\r\nval testDataProvider = new MnistDataProvider(\"data/mnist/t10k-images-idx3-ubyte\", \"data/mnist/t10k-labels-idx1-ubyte\")\r\n\r\nval testSetIsFit = (testDataProvider.read.set, MnistSupervisedDataSample.isFit _)\r\n\r\n// Number of nodes in the hidden layer ≈ √ (784 * 10)\r\nval net = FullyConnectedNet(GaussianWeightAssignment, SigmoidActivation, CrossEntropyCost, 784, 88, 10)\r\n\r\n// Train the network\r\nval trainer = BackPropagationTrainer(learningRate = 0.005, weightDecay = 0.5)\r\n\r\nval numberOfEpochs = 30\r\nval miniBatchSize = 10\r\n\r\n// First accuracy is the one of the untrained (random weights) network, second should be ≈ 90%; subsequent accuracies will improve\r\nval trainedNets = trainer.trainAndTest(net, numberOfEpochs, miniBatchSize, trainingDataProvider.read.set, testSetIsFit)\r\n\r\nval accuracy = trainer.test(trainedNets.last._1, testSetIsFit)\r\n\r\ntrainingDataProvider.close()\r\ntestDataProvider.close()\r\n```\r\n\r\n## skylark-measure\r\n\r\n**skylark-measure** is a library dealing with unit-of-measure conversions in a type-safe manner. Many libraries provide similar functionality on \r\ntheir surface but in the end lack the richness and versatility necessary to use in real enterprise applications.\r\n\r\nMany units of measure are defined for you.\r\n\r\n```scala\r\nkg\r\nlb\r\nPa\r\nHz\r\n```\r\n\r\nAny unit of measure will have a set of basic properties that you would naturally expect to interrogate.\r\n\r\n```scala\r\nkg.name should be(\"kg\")\r\nkg.dimension should be(Mass)\r\nkg.system should be(SI)\r\nkg.multBase.value should be((1000, g)) // Gram is a base unit of Mass in the SI system\r\n```\r\n\r\nYou can take existing units and compose more complex ones by multiplying, dividing, and exponentiating.\r\n\r\n```scala\r\nkg * m / sec ^ 2\r\n```\r\n\r\nYou can find our the conversion factor from one *to* another.  No conversion factor may exist.\r\n\r\n```scala\r\n(kg to lb).value should be(2.204625)\r\n```\r\n\r\nYou can attach substances (or, in general, assets) to units of measure to distinguish substances of different quality or composition, \r\nwhich can impact the conversion factor. For example, [West Texas Intermediate](http://en.wikipedia.org/wiki/West_Texas_Intermediate) (WTI) barrel of \r\noil has a different conversion factor to gallons than a barrel of water.\r\n\r\n```scala\r\n(bbl to gal).value should equal(31.5)\r\n(bbl of wti to gal).value should equal(42)\r\n```\r\nConversions are done though `implicit` *ConversionProviders*. The default *ConversionProviders* should suffice for most needs but you can roll your own at any time.\r\n\r\nToo many systems omit units of measure when storing or presenting numerical quantities. Now you can store units of measure along with a numeric value as a plain string.\r\nWith `MeasureParsers` you can turn that string back into a measure.\r\n \r\n```scala\r\nparseAll(measureExpression, \"USD / bbl\").get should be(USD / bbl)\r\nparseAll(measureExpression, \"((USD * (MMBtu / bbl) ^ 3) ^ 2) / MMBtu\").get should be(((USD * ((MMBtu / bbl) ^ 3)) ^ 2) / MMBtu)\r\n```\r\n\r\nIt's easy to compose numerical quantities with units of measure using a dot or postfix syntax. If the unit is structurally more complex than a single word, then\r\nuse the `*` syntax.\r\n\r\n```scala\r\n10.kg\r\n4 m\r\n1000 * (bbl of wti)\r\n```\r\n\r\nYou can perform the expected arithmetic operations on quantities.\r\n\r\n```scala\r\n10.kg * 5 should be(50.kg)\r\n10 * (kg of cotton)) * 5 should be(50 * (kg of cotton))\r\n10.kg * 4.m should be(40 * (kg * m))\r\n```\r\n\r\nArithmetic on different units may result in raw unit representation that may not be desirable. You may compact it as necessary.\r\n\r\n```scala\r\nval potOfGold = 30000.USD\r\nval rate = 5.percent\r\nval panOfGold = potOfGold * rate\r\npanOfGold should equal(1500 * (USD * UnitMeasure))\r\npanOfGold.measure.compact should equal(USD)\r\n```\r\n\r\nQuantity conversions are also supported via the same `to` operator.\r\n\r\n```scala\r\n((10 kg) to lb) should be(22.04625 lb)\r\n50 bp to percent should be(0.5.percent)\r\n```\r\n\r\nEven when measures have non-trivial structural complexity, quantity conversions work as expected.\r\n\r\n```scala\r\nval rhoPercent = 2.5 * ((USD / MMBtu) / percent)\r\nval rhoBasisPoint = rhoPercent to ((USD / MMBtu) / bp)\r\nrhoBasisPoint should equal(0.025 * ((USD / MMBtu) / bp))\r\n```\r\n\r\n## skylark-measure-market\r\n\r\n**skylark-measure-market** is a library that extends **skylark-measure** to the financial domain, where unit conversion factors are not fixed \r\nand normally vary as a function of time or space or both. For example, the conversion factor from US Dollars (`USD`) to Japanese Yen (`JPY`) will\r\ndepend on the observed time; similarly, a tanker of oil at two different locations around the globe will be worth a \r\ndifferent quantity of dollars, even when controlling for the currency exchange rate between the two locations.\r\n\r\nYou can control the variability of a particular unit of measure with respect to another (e.g. how does `bbl of WTI` vary with respect to `USD`, otherwise known as a price)\r\nby constructing a market manifold, which is a fancy name for a curve or a surface. In general, a market manifold is a function; in can be discrete or continuous and can\r\ngive you a value given a key.\r\n\r\nIn finance, a forward curve carries a price - a value of something vs. something else (e.g. `bbl of wti / USD` or `USD / GBP`).\r\n\r\n```scala\r\nval wtiForwardCurve = DiscreteForwardCurve(USD / (bbl of wti), Seq((\"2014-04-01\".d, 100.0), (\"2017-01-01\".d, 150.0)))\r\n```\r\n\r\nYou can combine multiple manifolds into a `Market`, which is a special kind of a bag carrying all data relevant to a given observation date/time.\r\n\r\n```scala\r\nval observationDate: DateTime = \"2014-04-01\".d\r\nval market = new GlobalMarket(\r\n    Seq(\r\n      TimeInstantCurve(observationDate),\r\n      DiscreteForwardCurve(USD / (bbl of wti), Seq((\"2014-04-01\".d, 100.0), (\"2017-01-01\".d, 150.0))),\r\n      DiscreteForwardCurve.flat(1.2 * (CAD / USD), observationDate.until(\"2018-01-01\".d).by(Days.ONE)),\r\n      DiscreteForwardCurve.flat(120 * (CAD / JPY), observationDate.until(\"2018-01-01\".d).by(Days.ONE)),\r\n      DiscreteForwardCurve.flat(100 * (USD / JPY), observationDate.until(\"2018-01-01\".d).by(Days.ONE))\r\n    )\r\n  )\r\n```\r\n\r\nNote that `observationDate` is attached to the `Market` via a special `TimeInstantCurve` instead of making it a special property of the `Market`.\r\n\r\nWith the above assembled, you can do a lot of neat stuff.\r\n\r\n```scala\r\nval barrelPrice = 42 * (USD / (bbl of wti))\r\nval gallonPrice = 1 * (CAD / gal)\r\n\r\nval price1 = (barrelPrice + gallonPrice) to (CAD / gal)\r\nval price2 = (gallonPrice + barrelPrice) to (USD / (bbl of wti))\r\n\r\nprice1.value should equal(2.2 +- 0.0000000000001)\r\nprice1.measure should be(CAD / gal)\r\n\r\nprice2.value should equal(77.0 +- 0.0000000000001)\r\nprice2.measure should be(USD / (bbl of wti))\r\n```","google":"UA-61924022-3","note":"Don't delete this file! It's used internally to help with page regeneration."}