{
  "name": "Skylark",
  "tagline": "Collection of libraries for quantitative and financial computation.",
  "body": "<!--\r\n  Title: Skylark\r\n  Description: Collection of libraries for quantitative and financial computation.\r\n  Author: Araik Grigoryan\r\n  Copyright: 2012-2016 Quantarray, LLC\r\n-->\r\n  \r\n<meta name='keywords' content='scala, unit of measure, skylark'>\r\n\r\n[![Build Status](https://travis-ci.org/quantarray/skylark.svg?branch=master)](https://travis-ci.org/quantarray/skylark)\r\n\r\n# Skylark\r\n\r\nSkylark is a collection of libraries for quantitative and financial computation.\r\n\r\n## skylark-measure\r\n\r\n**skylark-measure** is a library dealing with unit-of-measure conversions in a type-safe manner. Many libraries provide similar functionality on \r\ntheir surface but in the end lack the richness and versatility necessary to use in real enterprise applications.\r\n\r\n```scala\r\nlibraryDependencies += \"com.quantarray\" %% \"skylark-measure\" % \"0.12.0\"\r\n```\r\n\r\n```scala\r\nimport com.quantarray.skylark.measure._\r\nimport com.quantarray.skylark.measure.conversion.default._\r\nimport com.quantarray.skylark.measure.arithmetic.default._\r\n```\r\n\r\n### Simple usage\r\n\r\nMany units of measure are defined for you.\r\n\r\n```scala\r\nkg\r\nlb\r\nPa\r\nHz\r\n```\r\n\r\nAny unit of measure will have a set of basic properties that you would naturally expect to interrogate.\r\n\r\n```scala\r\nkg.name should be(\"kg\")\r\nkg.dimension should be(Mass)\r\nkg.system should be(SI)\r\nkg.isStructuralAtom should be(right = true)\r\nkg.exponent should be(1.0)\r\nkg / lb should be(Unit)\r\nkg * s should be(ProductMeasure(kg, s))\r\nkg.inverse should be(ExponentialMeasure(kg, -1.0))\r\nkg to kg should be(Some(1))\r\nkg to lb should be(Some(2.204625))\r\nkg to g should be(Some(1000))\r\nkg to cg should be(Some(100000))\r\nkg to oz_metric should be(None) // Default conversion is not guaranteed to exist\r\n```\r\n\r\nYou can take existing units and compose more complex ones by multiplying, dividing, and exponentiating.\r\n\r\n```scala\r\nval N = kg * m / sec ^ 2\r\n```\r\n\r\nYou can find our the conversion factor from one `to` another. No conversion factor may exist.\r\n\r\n```scala\r\n(kg to lb).value should be(2.204625)\r\n```\r\n\r\nMany systems omit units of measure when storing or presenting numerical quantities. Now you can store units of measure along with a numeric value as a plain string.\r\nWith `MeasureParsers` you can turn that string back into a measure.\r\n \r\n```scala\r\nparseMeasure(\"USD / bbl\").get should equal(USD / bbl)\r\n```\r\n\r\nIt's easy to compose numerical quantities with units of measure using a dot or postfix syntax.\r\n\r\n```scala\r\n10.kg\r\n4 m\r\n1000.0.bbl\r\n```\r\n\r\nYou can perform the expected arithmetic operations on quantities.\r\n\r\n```scala\r\n10.kg * 4.m should equal(40.0 * (kg * m))\r\n(4.oz_troy * 7.percent).to(oz_troy) should equal(0.28.oz_troy)\r\n\r\n10.kg / 2.m should equal(5.0 * (kg / m))\r\n(10.USD / 2.percent).to(USD) should equal(500.USD)\r\n\r\n10.kg + 3.kg should equal(13.kg)\r\n10.kg - 3.kg should equal(7.kg)\r\n10.kg + (3.lb to kg) should equal(11.360775642116007.kg)\r\n```\r\n\r\nQuantity conversions are also supported via the same `to` operator. Basic converters are pre-defined. Conversions for product, ratio, and exponential measures\r\nare defined by converters and require their own `CanConvert` instances of their components' conversions.\r\n\r\n```scala\r\n(1.ft to in) should equal(12.0 in)\r\n(12.in to ft) should equal(1.0 ft)\r\n```\r\n\r\n### Strongly-typed and untyped measures and quantities\r\n\r\n**skylark-measure** gives you the freedom and flexibility of working with strongly-typed measures (e.g. `MassMeasure`) or looser-typed `untyped.Measure`. \r\nThe choice of which to work with depends on the individual API you would like to expose and enforce.\r\n\r\nIn the situation where you know you must receive a `MassMeasure`, you would encode exactly as natural logic or physics would dictate. There is, hence, no chance\r\nsomeone can pass a quantity in units of `LuminousFluxMeasure`, for example, where a quantity in units of `MassMeasure` is expected (unless one finds compiler errors\r\naesthetically pleasing).\r\n\r\n```scala\r\ntype VelocityMeasure = RatioMeasure[LengthMeasure, TimeMeasure]\r\n\r\ntype MomentumMeasure = ProductMeasure[MassMeasure, VelocityMeasure]\r\n\r\ntype Mass = Quantity[Double, MassMeasure]\r\n\r\ntype Velocity = Quantity[Double, VelocityMeasure]\r\n\r\ntype Momentum = Quantity[Double, MomentumMeasure]\r\n\r\ndef momentum(mass: Mass, velocity: Velocity): Momentum = mass * velocity\r\n```\r\n\r\nIn other situations, where knowledge of a type of measure is uncertain, one would rely on an amorphous `untyped.Measure`, in package \r\n`com.quantarray.skylark.measure.untyped`. Operations on `untyped.Measure` yields another `untyped.Measure`. You can always `match` on an \r\n`untyped.Measure` to check or assert a certain shape.\r\n\r\n### Overriding default behavior\r\n\r\n#### Arithmetic\r\n\r\n**skylark-measure** relies on the presence of `implicit` type classes `CanMultiply`, `CanDivide`, and `CanExponentiate` to perform arithmetic operations. \r\n\r\nBy default \r\n\r\n* `m1 * m2` returns `ProductMeasure(m1, m2)`;\r\n* `m1 / m2` returns `RatioMeasure(m1, m2)`;\r\n* `m ^ n` return `ExponentialMeasure(m, n`).\r\n\r\nOne can, however, override the return type by proving a custom implicit object or class that derives from one of the three `Can*` traits.\r\n\r\nFor example, say when one does `b / s` (bits per second), one wants to work with a custom `BitRateMeasure` instead of the default `RatioMeasure(bit, s)`.\r\n  \r\nOne would then need to define the custom object like `InformationTimeCanDivide`:\r\n\r\n```scala\r\nobject custom extends com.quantarray.skylark.measure.arithmetic.DefaultImplicits\r\n{\r\n\r\n  implicit object InformationTimeCanDivide extends CanDivide[InformationMeasure, TimeMeasure, BitRateMeasure]\r\n  {\r\n    override def divide(numerator: InformationMeasure, denominator: TimeMeasure): BitRateMeasure = BitRateMeasure(numerator, denominator)\r\n  }\r\n\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}